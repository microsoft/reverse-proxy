<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Middleware </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Middleware ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="middleware">Middleware</h1>

<h2 id="introduction">Introduction</h2>
<p>ASP.NET Core uses a <a href="https://docs.microsoft.com/aspnet/core/fundamentals/middleware/">middleware pipeline</a> to divide request processing into discrete steps. The app developer can add and order middleware as needed. ASP.NET Core middleware is also used to implement and customize reverse proxy functionality.</p>
<h2 id="defaults">Defaults</h2>
<p>The <a href="getting-started.html">getting started</a> sample shows the following Configure method. This sets up a middleware pipeline with development tools, routing, and proxy configured endpoints (<code>MapReverseProxy</code>).</p>
<pre><code class="lang-C#">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    
    // Enable endpoint routing, required for the reverse proxy
    app.UseRouting();
    // Register the reverse proxy routes
    app.UseEndpoints(endpoints =&gt; 
    {
        endpoints.MapReverseProxy(); 
    }); 
} 
</code></pre>
<p>The parmeterless <code>MapReverseProxy()</code> in <a class="xref" href="../api/Microsoft.AspNetCore.Builder.ReverseProxyIEndpointRouteBuilderExtensions.html">ReverseProxyIEndpointRouteBuilderExtensions</a> overload includes all standard proxy middleware for <a href="session-affinity.html">session affinity</a>, <a href="load-balancing.html">load balancing</a>, <a href="dests-health-checks.html#passive-health-checks">passive health checks</a>, and the final proxying of the request. Each of these check the configuration of the matched route, cluster, and destination and perform their task accordingly.</p>
<h2 id="adding-middleware">Adding Middleware</h2>
<p>Middleware added to your application pipeline will see the request in different states of processing depending on where the middleware is added. Middleware added before <code>UseRouting</code> will see all requests and can manipulate them before any routing takes place. Middleware added between <code>UseRouting</code> and <code>UseEndpoints</code> can call <code>HttpContext.GetEndpoint()</code> to check which endpoint routing matched the request to (if any), and use any metadata that was associated with that endpoint. This is how <a href="authn-authz.html">Authentication, Authorization</a> and <a href="cors.html">CORS</a> are handled.</p>
<p><a class="xref" href="../api/Microsoft.AspNetCore.Builder.ReverseProxyIEndpointRouteBuilderExtensions.html">ReverseProxyIEndpointRouteBuilderExtensions</a> provides an overload of <code>MapReverseProxy</code> that lets you build a middleware pipeline that will run only for requests matched to proxy configured routes.</p>
<pre><code>endpoints.MapReverseProxy(proxyPipeline =&gt;
{
    proxyPipeline.Use((context, next) =&gt;
    {
        // Custom inline middleware

        return next();
    });
    proxyPipeline.UseSessionAffinity();
    proxyPipeline.UseLoadBalancing();
    proxyPipeline.UsePassiveHealthChecks();
});
</code></pre>
<p>By default this overload of <code>MapReverseProxy</code> only includes the minimal setup, proxying logic, and limit enforcement at the start and end of its pipeline. Middleware for session affinity, load balancing, and passive health checks are not included by default so that you can exclude, replace, or control their ordering with any additional middleware.</p>
<h2 id="custom-proxy-middleware">Custom Proxy Middleware</h2>
<p>Middlware inside the <code>MapReverseProxy</code> pipeline have access to all of the proxy data and state associated with a request (the route, cluster, destinations, etc.) through the <a class="xref" href="../api/Yarp.ReverseProxy.Model.IReverseProxyFeature.html">IReverseProxyFeature</a>. This is available from <code>HttpContext.Features</code> or the extension method <code>HttpContext.GetReverseProxyFeature()</code>.</p>
<p>The data in <code>IReverseProxyFeature</code> are snapshotted from the proxy configuration at the start of the proxy pipeline and will not be affected by proxy configuration changes that occur while the request is being processed.</p>
<pre><code class="lang-C#">proxyPipeline.Use((context, next) =&gt;
{
    var proxyFeature = context.GetReverseProxyFeature();
    var cluster = proxyFeature.Cluster;
    var destinations = proxyFeature.AvailableDestinations;

    return next();
});
</code></pre>
<h2 id="what-to-do-with-middleware">What to do with middleware</h2>
<p>Middleware can generate logs, control if a request gets proxied or not, influence where it's proxied to, and add additional features like error handling, retries, etc..</p>
<h3 id="logs-and-metrics">Logs and Metrics</h3>
<p>Middleware can inspect request and response fields to generate logs and aggregate metrics. See the note about bodies under &quot;What not to do with middleware&quot; below.</p>
<pre><code class="lang-C#">proxyPipeline.Use(async (context, next) =&gt;
{
    LogRequest(context);
    await next();
    LogResponse(context);
});
</code></pre>
<h3 id="send-an-immediate-response">Send an immediate response</h3>
<p>If a middleware inspects a request and determines that it should not be proxied, it may generate its own response and return control to the server without calling <code>next()</code>.</p>
<pre><code class="lang-C#">proxyPipeline.Use((context, next) =&gt;
{
    if (!CheckAllowedRequest(context, out var reason))
    {
        context.Response.StatusCode = StatusCodes.Status400BadRequest;
        return context.Response.WriteAsync(reason);
    }

    return next();
});
</code></pre>
<h3 id="filter-destinations">Filter destinations</h3>
<p>Middleware like session affinity and load balancing examine the <code>IReverseProxyFeature</code> and the cluster configuration to decide which destination a request should be sent to.</p>
<p><code>AllDestinations</code> lists all destinations in the selected cluster.</p>
<p><code>AvailableDestinations</code> lists the destinations currently considered eligible to handle the request. It is initialized to <code>AllDestinations</code>, excluding unhealthy ones if health checks are enabled. <code>AvailableDestinations</code> should be reduced to a single destination by the end of the pipeline or else one will be selected randomly from the remainder.</p>
<p><code>ProxiedDestination</code> is set by the proxy logic at the end of the pipeline to indicate which destination was ultimately used.  If there are no available destinations remaining then a 503 error response is sent.</p>
<pre><code class="lang-C#">proxyPipeline.Use(async (context, next) =&gt;
{
    var proxyFeature = context.GetReverseProxyFeature();
    proxyFeature.AvailableDestinations = Filter(proxyFeature.AvailableDestinations);

    await next();

    Report(proxyFeature.ProxiedDestination);
});
</code></pre>
<p><code>DestinationState</code> implements <code>IReadOnlyList&lt;DestinationState&gt;</code> so a single destination can be assigned to <code>AvailableDestinations</code> without creating a new list.</p>
<h3 id="error-handling">Error handling</h3>
<p>Middleware can wrap the call to <code>await next()</code> in a try/catch block to handle exceptions from later components.</p>
<p>The proxy logic at the end of the pipeline (<a href="direct-forwarding.html">IHttpForwarder</a>) does not throw exceptions for common request proxy errors. These are captured and reported in the <a class="xref" href="../api/Yarp.ReverseProxy.Forwarder.IForwarderErrorFeature.html">IForwarderErrorFeature</a> available from <code>HttpContext.Features</code> or the <code>HttpContext.GetForwarderErrorFeature()</code> extension method.</p>
<pre><code class="lang-C#">proxyPipeline.Use(async (context, next) =&gt;
{
    await next();

    var errorFeature = context.GetForwarderErrorFeature();
    if (errorFeature is not null)
    {
        Report(errorFeature.Error, errorFeature.Exception);
    }
});
</code></pre>
<p>If the response has not started (<code>HttpResponse.HasStarted</code>) it can be cleared (<code>HttpResponse.Clear()</code>) and an alternate response sent, or the proxy feature fields may be reset and the request retried.</p>
<h2 id="what-not-to-do-with-middleware">What not to do with middleware</h2>
<p>Middleware should be cautious about modifying request fields such as headers in order to affect the outgoing proxied request. Such modifications may interfere with features like retries and may be better handled by <a href="transforms.html">transforms</a>.</p>
<p>Middleware MUST check <code>HttpResponse.HasStarted</code> before modifying response fields after calling <code>next()</code>. If the response has already started being sent to the client then the middleware can no longer modify it (except maybe Trailers). <a href="transforms.html">Transforms</a> can be used to inspect and suppress unwanted responses. Otherwise see the next note.</p>
<p>Middleware should avoid interacting with the request or response bodies. Bodies are not buffered by default, so interacting with them can prevent them from reaching their destinations. While enabling buffering is possible, it's discouraged as it can add significant memory and latency overhead. Using a wrapped, streaming approach is recommended if the body must be examined or modified. See the <a href="https://github.com/dotnet/aspnetcore/blob/24588220006bc164b63293129cc94ac6292250e4/src/Middleware/ResponseCompression/src/ResponseCompressionMiddleware.cs#L55-L73">ResponseCompression</a> middleware for an example.</p>
<p>Middleware MUST NOT do any multi-threaded work on an individual request, <code>HttpContext</code> and its associated members are not thread safe.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/microsoft/reverse-proxy/blob/release/latest/docs/docfx/articles/middleware.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
