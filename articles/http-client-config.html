<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>HTTP Client Configuration </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="HTTP Client Configuration ">
    <meta name="generator" content="docfx 2.58.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="http-client-configuration">HTTP Client Configuration</h1>

<h2 id="introduction">Introduction</h2>
<p>Each <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.ClusterConfig.html">Cluster</a> has a dedicated <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpmessageinvoker">HttpMessageInvoker</a> instance used to forward requests to its <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.DestinationConfig.html">Destination</a>s. The configuration is defined per cluster. On YARP startup, all clusters get new <code>HttpMessageInvoker</code> instances, however if later the cluster configuration gets changed the <a class="xref" href="../api/Yarp.ReverseProxy.Forwarder.IForwarderHttpClientFactory.html">IForwarderHttpClientFactory</a> will re-run and decide if it should create a new <code>HttpMessageInvoker</code> or keep using the existing one. The default <code>IForwarderHttpClientFactory</code> implementation creates a new <code>HttpMessageInvoker</code> when there are changes to the <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.HttpClientConfig.html">HttpClientConfig</a>.</p>
<p>Properties of outgoing requests for a given cluster can be configured as well. They are defined in <a class="xref" href="../api/Yarp.ReverseProxy.Forwarder.ForwarderRequestConfig.html">ForwarderRequestConfig</a>.</p>
<p>The configuration is represented differently if you're using the <a href="https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfiguration">IConfiguration</a> model or the code-first model.</p>
<h2 id="iconfiguration">IConfiguration</h2>
<p>These types are focused on defining serializable configuration. The code based configuration model is described below in the &quot;Code Configuration&quot; section.</p>
<h3 id="httpclient">HttpClient</h3>
<p>HTTP client configuration is based on <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.HttpClientConfig.html">HttpClientConfig</a> and represented by the following configuration schema.</p>
<pre><code class="lang-JSON">&quot;HttpClient&quot;: {
    &quot;SslProtocols&quot;: [ &quot;&lt;protocol-names&gt;&quot; ],
    &quot;MaxConnectionsPerServer&quot;: &quot;&lt;int&gt;&quot;,
    &quot;DangerousAcceptAnyServerCertificate&quot;: &quot;&lt;bool&gt;&quot;,
    &quot;RequestHeaderEncoding&quot;: &quot;&lt;encoding-name&gt;&quot;,
    &quot;EnableMultipleHttp2Connections&quot;: &quot;&lt;bool&gt;&quot;
    &quot;WebProxy&quot;: {
        &quot;Address&quot;: &quot;&lt;url&gt;&quot;,
        &quot;BypassOnLocal&quot;: &quot;&lt;bool&gt;&quot;,
        &quot;UseDefaultCredentials&quot;: &quot;&lt;bool&gt;&quot;
    }
}
</code></pre>
<p>Configuration settings:</p>
<ul>
<li>SslProtocols - <a href="https://docs.microsoft.com/dotnet/api/system.security.authentication.sslprotocols">SSL protocols</a> enabled on the given HTTP client. Protocol names are specified as array of strings. Default value is <a href="https://docs.microsoft.com/dotnet/api/system.security.authentication.sslprotocols#System_Security_Authentication_SslProtocols_None">None</a>.</li>
</ul>
<pre><code class="lang-JSON">&quot;SslProtocols&quot;: [
    &quot;Tls11&quot;,
    &quot;Tls12&quot;
]
</code></pre>
<ul>
<li>MaxConnectionsPerServer - maximal number of HTTP 1.1 connections open concurrently to the same server. Default value is <a href="https://docs.microsoft.com/dotnet/api/system.int32.maxvalue">int32.MaxValue</a>.</li>
</ul>
<pre><code class="lang-JSON">&quot;MaxConnectionsPerServer&quot;: &quot;10&quot;
</code></pre>
<ul>
<li>DangerousAcceptAnyServerCertificate - indicates whether the server's SSL certificate validity is checked by the client. Setting it to <code>true</code> completely disables validation. Default value is <code>false</code>.</li>
</ul>
<pre><code class="lang-JSON">&quot;DangerousAcceptAnyServerCertificate&quot;: &quot;true&quot;
</code></pre>
<ul>
<li>RequestHeaderEncoding - enables other than ASCII encoding for outgoing request headers. Setting this value will leverage <a href="https://docs.microsoft.com/dotnet/api/system.net.http.socketshttphandler.requestheaderencodingselector"><code>SocketsHttpHandler.RequestHeaderEncodingSelector</code></a> and use the selected encoding for all headers. If you need more granular approach, please use custom <code>IProxyHttpClientFactory</code>. The value is then parsed by <a href="https://docs.microsoft.com/dotnet/api/system.text.encoding.getencoding#System_Text_Encoding_GetEncoding_System_String_"><code>Encoding.GetEncoding</code></a>, use values like: &quot;utf-8&quot;, &quot;iso-8859-1&quot;, etc. <strong>This setting is only available for .NET 5.0.</strong></li>
</ul>
<pre><code class="lang-JSON">&quot;RequestHeaderEncoding&quot;: &quot;utf-8&quot;
</code></pre>
<p>If you're using an encoding other than ASCII (or UTF-8 for Kestrel) you also need to set your server to accept requests with such headers. For example, use <a href="https://docs.microsoft.com/dotnet/api/Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.RequestHeaderEncodingSelector"><code>KestrelServerOptions.RequestHeaderEncodingSelector</code></a> to set up Kestrel to accept Latin1 (&quot;iso-8859-1&quot;) headers:</p>
<pre><code class="lang-C#">private static IHostBuilder CreateHostBuilder(string[] args) =&gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =&gt;
        {
            webBuilder.UseStartup&lt;Startup&gt;()
                      .ConfigureKestrel(kestrel =&gt;
                      {
                          kestrel.RequestHeaderEncodingSelector = _ =&gt; Encoding.Latin1;
                      });
        );
</code></pre>
<ul>
<li>EnableMultipleHttp2Connections - enables opening additional HTTP/2 connections to the same server when the maximum number of concurrent streams is reached on all existing connections. The default is <code>true</code>. <strong>This feature is available from .NET 5.0</strong>, see <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler.enablemultiplehttp2connections">SocketsHttpHandler.EnableMultipleHttp2Connections</a></li>
</ul>
<pre><code class="lang-JSON">&quot;EnableMultipleHttp2Connections&quot;: false
</code></pre>
<ul>
<li>WebProxy - Enables sending requests through an outbound HTTP proxy to reach the destinations. See <a href="https://docs.microsoft.com/dotnet/api/system.net.http.socketshttphandler.proxy"><code>SocketsHttpHandler.Proxy</code></a> for details.
<ul>
<li>Address - The url address of the outbound proxy.</li>
<li>BypassOnLocal - A bool indicating if requests to local addresses should bypass the outbound proxy.</li>
<li>UseDefaultCredentials - A bool indicating if the current application credentials should be use to authenticate to the outbound proxy. ASP.NET Core does not impersonate authenticated users for outbound requests.</li>
</ul>
</li>
</ul>
<pre><code class="lang-JSON">&quot;WebProxy&quot;: {
    &quot;Address&quot;: &quot;http://myproxy:8080&quot;,
    &quot;BypassOnLocal&quot;: &quot;true&quot;,
    &quot;UseDefaultCredentials&quot;: &quot;false&quot;
}
</code></pre>
<p>For .NET Core 3.1, Latin1 (&quot;iso-8859-1&quot;) is the only non-ASCII header encoding that can be accepted and only via <code>appsettings.json</code>:</p>
<pre><code class="lang-JSON">{
    &quot;Kestrel&quot;:
    {
        &quot;Latin1RequestHeaders&quot;: true
    }
}
</code></pre>
<p>together with an application wide switch:</p>
<pre><code class="lang-C#">AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.AllowLatin1Headers&quot;, true);
</code></pre>
<p>At the moment, there is no solution for changing encoding for response headers in Kestrel (see <a href="https://github.com/dotnet/aspnetcore/issues/26334">aspnetcore#26334</a>), only ASCII is accepted.</p>
<h3 id="httprequest">HttpRequest</h3>
<p>HTTP request configuration is based on <a class="xref" href="../api/Yarp.ReverseProxy.Forwarder.ForwarderRequestConfig.html">ForwarderRequestConfig</a> and represented by the following configuration schema.</p>
<pre><code class="lang-JSON">&quot;HttpRequest&quot;: {
    &quot;ActivityTimeout&quot;: &quot;&lt;timespan&gt;&quot;,
    &quot;Version&quot;: &quot;&lt;string&gt;&quot;,
    &quot;VersionPolicy&quot;: [&quot;RequestVersionOrLower&quot;, &quot;RequestVersionOrHigher&quot;, &quot;RequestVersionExact&quot;],
    &quot;AllowResponseBuffering&quot;: &quot;&lt;bool&gt;&quot;
}
</code></pre>
<p>Configuration settings:</p>
<ul>
<li>ActivityTimeout - how long a request is allowed to remain idle between any operation completing, after which it will be canceled. The default is 100 seconds. The timeout will reset when response headers are received or after successfully reading or writing any request, response, or streaming data like gRPC or WebSockets. TCP keep-alives and HTTP/2 protocol pings will not reset the timeout, but WebSocket pings will.</li>
<li>Version - outgoing request <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httprequestmessage.version">version</a>. The supported values at the moment are <code>1.0</code>, <code>1.1</code>, <code>2</code> and <code>3</code>. Default value is 2.</li>
<li>VersionPolicy - defines how the final version is selected for the outgoing requests. <strong>This feature is available from .NET 5.0</strong>, see <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httprequestmessage.versionpolicy">HttpRequestMessage.VersionPolicy</a>. The default value is <code>RequestVersionOrLower</code>.</li>
<li>AllowResponseBuffering - allows to use write buffering when sending a response back to the client, if the server hosting YARP (e.g. IIS) supports it. <strong>NOTE</strong>: enabling it can break SSE (server side event) scenarios.</li>
</ul>
<h2 id="configuration-example">Configuration example</h2>
<p>The below example shows 2 samples of HTTP client and request configurations for <code>cluster1</code> and <code>cluster2</code>.</p>
<pre><code class="lang-JSON">{
    &quot;Clusters&quot;: {
        &quot;cluster1&quot;: {
            &quot;LoadBalancingPolicy&quot;: &quot;Random&quot;,
            &quot;HttpClient&quot;: {
                &quot;SslProtocols&quot;: [
                    &quot;Tls11&quot;,
                    &quot;Tls12&quot;
                ],
                &quot;MaxConnectionsPerServer&quot;: &quot;10&quot;,
                &quot;DangerousAcceptAnyServerCertificate&quot;: &quot;true&quot;
            },
            &quot;HttpRequest&quot;: {
                &quot;ActivityTimeout&quot;: &quot;00:00:30&quot;
            },
            &quot;Destinations&quot;: {
                &quot;cluster1/destination1&quot;: {
                    &quot;Address&quot;: &quot;https://localhost:10000/&quot;
                },
                &quot;cluster1/destination2&quot;: {
                    &quot;Address&quot;: &quot;http://localhost:10010/&quot;
                }
            }
        },
        &quot;cluster2&quot;: {
            &quot;HttpClient&quot;: {
                &quot;SslProtocols&quot;: [
                    &quot;Tls12&quot;
                ]
            },
            &quot;HttpRequest&quot;: {
                &quot;Version&quot;: &quot;1.1&quot;,
                &quot;VersionPolicy&quot;: &quot;RequestVersionExact&quot;
            },
            &quot;Destinations&quot;: {
                &quot;cluster2/destination1&quot;: {
                    &quot;Address&quot;: &quot;https://localhost:10001/&quot;
                }
            }
        }
    }
}
</code></pre>
<h2 id="code-configuration">Code Configuration</h2>
<p>HTTP client configuration uses the type <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.HttpClientConfig.html">HttpClientConfig</a>.</p>
<p>The following is an example of <code>HttpClientConfig</code> using <a href="config-providers.html">code based</a> configuration. An instance of <code>HttpClientConfig</code> is assigned to the <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.ClusterConfig.html">ClusterConfig.HttpClient</a> property before passing the cluster array to <code>LoadFromMemory</code> method.</p>
<pre><code class="lang-C#">public void ConfigureServices(IServiceCollection services)
{
    var routes = new[]
    {
        new RouteConfig()
        {
            RouteId = &quot;route1&quot;,
            ClusterId = &quot;cluster1&quot;,
            Match =
            {
                Path = &quot;{**catch-all}&quot;
            }
        }
    };
    var clusters = new[]
    {
        new ClusterConfig()
        {
            ClusterId = &quot;cluster1&quot;,
            Destinations =
            {
                { &quot;destination1&quot;, new DestinationConfig() { Address = &quot;https://localhost:10000&quot; } }
            },
            HttpClient = new HttpClientConfig { MaxConnectionsPerServer = 10, SslProtocols = SslProtocols.Tls11 | SslProtocols.Tls12 }
        }
    };

    services.AddReverseProxy()
        .LoadFromMemory(routes, clusters);
}
</code></pre>
<h2 id="configuring-the-http-client">Configuring the http client</h2>
<p><code>ConfigureHttpClient</code> provides a callback to customize the <code>SocketsHttpHandler</code> settings used for proxying requests. This will be called each time a cluster is added or changed. Cluster settings are applied to the handler before the callback. Custom data can be provided in the cluster metadata. This example shows adding a client certificate that will authenticate the proxy to the destination servers.</p>
<pre><code class="lang-C#">    var clientCert = new X509Certificate2(&quot;path&quot;);
    services.AddReverseProxy()
        .ConfigureHttpClient((context, handler) =&gt;
        {
            handler.SslOptions.ClientCertificates.Add(clientCert);
        })
</code></pre>
<h2 id="custom-iforwarderhttpclientfactory">Custom IForwarderHttpClientFactory</h2>
<p>If direct control of HTTP client construction is necessary, the default <a class="xref" href="../api/Yarp.ReverseProxy.Forwarder.IForwarderHttpClientFactory.html">IForwarderHttpClientFactory</a> can be replaced with a custom one. For some customizations you can derive from the default <a class="xref" href="../api/Yarp.ReverseProxy.Forwarder.ForwarderHttpClientFactory.html">ForwarderHttpClientFactory</a> and override the methods that configure the client.</p>
<p>It's recommended that any custom factory set the following <code>SocketsHttpHandler</code> properties to the same values as the default factory does in order to preserve a correct reverse proxy behavior and avoid unnecessary overhead.</p>
<pre><code class="lang-C#">new SocketsHttpHandler
{
    UseProxy = false,
    AllowAutoRedirect = false,
    AutomaticDecompression = DecompressionMethods.None,
    UseCookies = false,
    ActivityHeadersPropagator = new ReverseProxyPropagator(DistributedContextPropagator.Current)
};
</code></pre>
<p>Always return an HttpMessageInvoker instance rather than an HttpClient instance which derives from HttpMessageInvoker. HttpClient buffers responses by default which breaks streaming scenarios and increases memory usage and latency.</p>
<p>Custom data can be provided in the cluster metadata.</p>
<p>The below is an example of a custom <code>IForwarderHttpClientFactory</code> implementation.</p>
<pre><code class="lang-C#">public class CustomForwarderHttpClientFactory : IForwarderHttpClientFactory
{
    public HttpMessageInvoker CreateClient(ForwarderHttpClientContext context)
    {
        var handler = new SocketsHttpHandler
        {
            UseProxy = false,
            AllowAutoRedirect = false,
            AutomaticDecompression = DecompressionMethods.None,
            UseCookies = false,
            ActivityHeadersPropagator = new ReverseProxyPropagator(DistributedContextPropagator.Current)
        };

        return new HttpMessageInvoker(handler, disposeHandler: true);
    }
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/microsoft/reverse-proxy/blob/release/latest/docs/docfx/articles/http-client-config.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
